Day 2 

- JPQL
    - Be able to explain the purpose of JPQL and how it differs from SQL.
    - Be able to write JPQL queries using the SELECT, FROM, WHERE, GROUP BY, HAVING, and ORDER BY clauses.
    - Be able to write JPQL queries using aggregate functions like COUNT, SUM, MIN, MAX, and AVG.
    - Be able to explain and demonstrate Named Queries.
    - Be able to explain the difference between TypedQuery vs Query in JPA.
- JPA entities and annotations
    - Be able to explain and demonstrate JPA lifecycle annotations like @PrePersist, @PostPersist, @PreUpdate, @PostUpdate, @PreRemove, @PostRemove, @PostLoad
    - Understand the purpose of Lombok and how it reduces boilerplate code in Java entities.
- Data Access Object (DAO) Architecture
    - Be able to explain the benefits of using a DAO architecture for separating database access logic from business logic.
- Date and Time
    - Explore how Java Date and Time API integrates with JPA for managing date and time-related data.
    - Handle different types of date and time data using JPA annotations.




**JPA lifecycle annotations**

1. Pre-Persist (@PrePersist):
   This event is triggered just before an entity is persisted to the database.
   It's commonly used for tasks like setting default values, generating timestamps, or performing validation before insertion.

2. Pre-Update (@PreUpdate):
   This event occurs before an entity is updated in the database.
   It's often used for updating timestamps, tracking changes, or performing validation before updates.

3. Pre-Remove (@PreRemove):
   This event is triggered just before an entity is removed from the database.
   It can be used for actions like cleaning up associated data or performing validation before deletion.

4. Post-Persist (@PostPersist):
   This event occurs after an entity has been persisted to the database.
   It can be useful for tasks that need to be performed after a successful insertion, such as sending notifications or updating related entities.

5. Post-Update (@PostUpdate):
   This event is triggered after an entity has been updated in the database.
   It's often used for auditing, logging changes, or triggering additional actions based on updates.

6. Post-Remove (@PostRemove):
   This event occurs after an entity has been removed from the database.
   It can be used for tasks like updating related entities, generating historical records, or logging deletion events.

7. Post-Load (@PostLoad):
   This event is triggered when an entity is retrieved from the database.
   It's commonly used to initialize transient fields, calculate derived values, or perform additional loading-related operations.

***

## 4. Data Access Object (DAO) architecture

The Data Access Object (DAO) architecture is a design pattern that separates the data access logic from the rest of an application's business logic. It provides an abstraction layer between the application's domain/business logic and the underlying data storage mechanism (usually a relational database). The DAO pattern aims to improve modularity, maintainability, and code reusability by encapsulating data-related operations in dedicated classes.

Here's how the DAO architecture works:

1. **Data Access Objects (DAOs):**
    - DAOs are classes that encapsulate the logic for accessing and manipulating data in a specific data source (e.g., a database table).
    - Each DAO is responsible for a specific entity or data structure and provides methods for common operations like CRUD (Create, Read, Update, Delete).

2. **Domain/Business Logic:**
    - The core business logic of an application resides in the higher layers, separate from the DAOs.
    - The business logic uses DAO methods to interact with the data source without needing to know the specific details of data access.

3. **Abstraction:**
    - The DAO pattern provides an abstraction layer that hides the complexities of data access and database interactions.
    - This abstraction allows changes to the data source (such as switching databases) without affecting the application's business logic.

4. **Isolation:**
    - By isolating data access code in DAOs, changes to the database schema, queries, or data access logic can be localized to the DAO classes.
    - This isolation minimizes the impact of changes on the rest of the application.

5. **Code Reusability:**
    - DAOs promote code reusability by centralizing data access logic. Other parts of the application can reuse the same DAO methods across different components.

6. **Testing:**
    - DAOs can be individually tested in isolation using mock data sources or in-memory databases, making testing of data access logic more focused and controllable.

7. **Transaction Management:**
    - DAOs can encapsulate transaction management logic, ensuring that data operations within a single transaction are consistent and adhere to the ACID properties.

8. **Decoupling:**
    - The DAO pattern reduces coupling between data access and application logic. This separation makes the codebase more modular and easier to maintain.

A simplified example of a DAO might involve a `UserDAO` class that provides methods for CRUD operations on a `User` entity. The business logic in the application can then use these methods to interact with user data without needing to know the specific details of the database interactions.

The DAO pattern is commonly used in combination with other design patterns and frameworks, such as Object-Relational Mapping (ORM) tools like Hibernate or JPA, to further simplify and streamline the data access process.